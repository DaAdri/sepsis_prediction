\title{rapport_stage}
\author{sifax ziani}
\date{May 2024}

\documentclass[a4paper,12pt]{article}
%\usepackage[ansinew]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{graphicx}
\usepackage{array}
%\usepackage{biblatex} %Imports biblatex package
%\addbibresource{bibliographie.bib} %Import the bibliography file

\title{rapport_stage}
\author{sifax ziani}
\date{May 2024}

\setlength{\parskip}{1em}  % Laisser un espace entre les paragraphes
\setlength{\parindent}{0em}  % Ne pas indenter les d√©buts des paragraphes

\begin{document} 

\section{Message encoding rules}
In previous sections HL7 messages were defined as abstract sequences of segments. To construct the actual sequence of bytes that represents an abstract message one must apply encoding rules. Any set of rules may be used by site agreement and the systems at the site will be considered in conformance with HL7 at the level of the abstract message. This section describes one particular set, the HL7 encoding rules. Systems that follow these rules are compatible with HL7 at the Encoding Rules level.
The encoding rules describe how each segment is constructed and some related processing logic. Constructing the segments in sequence creates a complete HL7 message.
\subsection{Definitions}
In constructing a message certain special characters are used. They are the segment terminator, the field separator, the component separator, subcomponent separator and the repetition separator.
\subsection*{Segment Terminator}
The segment terminator is the last character of every segment. It is always the ASCII CR character (hex 0D).
\subsection*{Field Separator}
The field separator separates two adjacent data fields within a segment. It also separates the segment ID from the first data field in the segment. The value that represents the field separator may be defined differently for each message. Whatever character is the fourth character of the MSH segment serves as the field separator for all segments in the message. Absent other considerations, it is recommended that all sending applications use '|' as the field separator. However, all receiving applications are required to accept whatever character is included in this position and use it to parse the message.
\subsection*{Component Separator}
The component separator is used to separate adjacent components of some data fields. Its use is described in the descriptions of the relevant data fields. The character that represents the component separator is specified for each message as the first character in the Encoding Characters data field of the MSH segment. Absent other considerations it is recommended that all sending applications use 
 "\textasciicircum" as the component separator. However, all applications are required to accept whatever character is included in the Message Header and use it to parse the message.
\subsection*{Sub-Component Separator}
The sub-component separator is used to separate adjacent sub-components of some data fields. Its use is described in the descriptions of the relevant data fields. The character that represents the sub-component separator is specified for each message as the fourth character in the Encoding Characters data field of the MSH segment. Absent other considerations it is recommended that all sending applications use "\&" as the sub-component separator. However, all applications are required to accept whatever character is included in the Message Header and use it to parse the message.
\subsection*{Repetition Separator}
The repetition separator is used in some data fields to separate multiple occurrences of a field. It is used only where specifically authorized in the descriptions of the relevant data fields. The character that represents the repetition separator is specified for each message as the second character in the Encoding Characters data field of the MSH segment. Absent other considerations it is recommended that all sending applications use "\textasciitilde" as the repetition separator. However, all applications are required to accept whatever character is included in the Message Header and use it to parse the message.
\subsection*{Escape Character}
In text fields (Type TX or FT) another special character is allowed, the escape character. Any character allowed in a TX or FT field may serve as the escape character. Its use is described in the discussion on coding text fields, below. The single character that represents the escape character is specified differently for each message as the third character in the Encoding Characters data field of the MSH segment. This field is optional. Applications that do not need to use an escape character may omit this character. Absent other considerations it is recommended that all sending applications use "\textbackslash" as the escape character. However, all applications are required to accept whatever character is included in this field and use it to parse text fields within the message.
\subsection{Message Construction Rules}
\begin{enumerate}
    \item  Construct the segments in the order defined for the message. Each message is constructed as follows:
    \begin{itemize}
        \item The first 3 characters are the segment id code.
        \item Each data field in sequence is inserted in the segment in the following manner:
        \begin{itemize}
            \item A field separator is placed in the segment.
            \item If the value is 'not present', no further characters are required.
            \item If the value is present, but null, the characters '""' (two consecutive double quotation marks) are placed in the field.
            \item Otherwise, place the characters of the value in the segment. As many characters can be included as the maximum defined for data field. It is not necessary, and is undesirable, to pad fields to fixed lengths. Padding to fixed lengths is permitted.Encode the individual data fields as shown in "Encoding HL7 Data Types," below.
            \item If the field definition calls for a field to be broken into components, the following rules are used:
            \begin{itemize}
                \item If more than one component is included they are separated by the component separator.
                \item components that are present but null are represented by the characters "".
                \item components that are not present are treated by including no characters in the component.
                \item components that are not present at the end of a field need not be represented by component separators. For example, the two data fields are equivalent: \textbf{|ABC^DEF^^| and |ABC^DEF|}
            \end{itemize}
            \item If the component definition calls for a component to be broken into sub-components, the following rules are used:
            \begin{itemize}
                \item If more than one sub-component is included they are separated by the sub-component separator.
                \item sub-components that are present but null are represented by the characters "".
                \itemsub-components that are not present are treated by including no characters in the sub-component.
                \itemsub-components that are not present at the end of a component need not be represented by sub-component separators. For example, the two data components are equivalent: \textbf{^XXX&YYY&&^ and ^XXX&YYY^}
            \end{itemize}
            \item If the field definition permits repetition of a field, the following rules are used, the repetition separator is used only if more than one occurrence is transmitted and is placed between occurrences. (If three occurrences are transmitted, two repetition separators are used.) In the example below, two occurrences of telephone number are being sent: \textbf{|234-7120~599-1288B1234|}
        \end{itemize}
        \item Repeat step (b) while there are any data elements 'present' to be sent. If all the data fields remaining in the segment definition are "not present" there is no requirement to include any more delimiters.
        \item End each segment with an ASCII carriage return character.   
    \end{itemize}
    \item Repeat step (1) until all segments have been generated.
\end{enumerate}
1) Construct the segments in the order defined for the message. Each message is constructed as follows:
a) The first 3 characters are the segment id code.
b) Each data field in sequence is inserted in the segment in the following manner:
i) A field separator is placed in the segment.
ii) If the value is 'not present', no further characters are required.
iii) If the value is present, but null, the characters '""' (two consecutive double quotation marks) are placed in the field.
iv) Otherwise, place the characters of the value in the segment. As many characters can be included as the maximum defined for data field. It is not necessary, and is undesirable, to pad fields to fixed lengths. Padding to fixed lengths is permitted.
Encode the individual data fields as shown in "Encoding HL7 Data Types," below.
v) If the field definition calls for a field to be broken into components, the following rules are used:
(a) If more than one component is included they are separated by the component separator.
(b) components that are present but null are represented by the characters "".
(c) components that are not present are treated by including no characters in the component.
(d) components that are not present at the end of a field need not be represented by component separators. For example, the two data fields are equivalent:
|ABC^DEF^^| and |ABC^DEF|.
vi) If the component definition calls for a component to be broken into sub-components, the following rules are used:
(a) If more than one sub-component is included they are separated by the sub-component separator.
(b) sub-components that are present but null are represented by the characters "".
(c) sub-components that are not present are treated by including no characters in the sub-component.
(d) sub-components that are not present at the end of a component need not be represented by sub-component separators. For example, the two data components are equivalent:
^XXX&YYY&&^ and ^XXX&YYY^.
vii) If the field definition permits repetition of a field, the following rules are used, the repetition separator is used only if more than one occurrence is transmitted and is placed between occurrences. (If three occurrences are transmitted, two repetition separators are used.) In the example below, two occurrences of telephone number are being sent:
|234-7120~599-1288B1234|
c) Repeat step (b) while there are any data elements 'present' to be sent. If all the data fields remaining in the segment definition are "not present" there is no requirement to include any more delimiters.
d) End each segment with an ASCII carriage return character.
2) Repeat step (1) until all segments have been generated.
The following rules apply to receiving HL7 messages and converting their contents to data values:
1) Ignore segments, fields, components, and extra repetitions of a field that are present but were not expected.
2) Treat segments that were expected but are not present as consisting entirely of fields that are "not present."
3) Treat fields and components that are expected but were not included in a segment as "not present."
4) In applications that cannot deal with the distinction between data fields that are not present and those that are null, treat data fields that are not present as null.
\begin{table}[h]
\centering
\caption{hl7 data types description}
    \begin{tabu} to \textwidth {|X[] | X[]|}
    \toprule
        \textbf{Data Typse} & \textbf{Description}\\
    \midrule   
        AD	& address	\\
        CE	& coded element	\\
        CK	& composite ID with check digit	\\
        CM	& CM	\\
        CM	& undefined CM data type\\	
        CN	& composite ID number and name	\\
        CK	& COMPOSITE ID W/CHK DIGIT	\\
        CN	& COMPOSITE ID AND NAME	\\
        CQ	& COMPOSITE QUANTITY/UNITS	\\
        DT	& DATE	\\
        FT	& formatted text data	\\
        ID	& CODED VALUE	\\
        NM	& numeric	\\
        PN	& person name	\\
        SI	& SET ID\\	
        ST	& string data	\\
        TM	& time	\\
        TN	& telephone number\\
        TS	& time stamp	\\
        TX	& text data	\\
    \bottomrule
    \end{tabu}
\end{table}
    
\end{document}
